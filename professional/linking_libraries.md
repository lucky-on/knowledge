Linking Libraries

* Are you building a dynamic library? Or an executable?
    * Are you linking to a dynamic library?
        * No problem! This is what libraries are designed for! A reference to the library you depend on will be added to the dynamic library you’re building. Once built, your client’s linkers can use your library without needing to know about the libraries you’re linked to. However, the dynamic library you link to WILL need to be available at runtime (and test time), so that the loader can find it. There are several ways to tell the loader where to find dependencies, including the LD_LIBRARY_PATH environment variable and the RPATH/RUNPATH value stored in the library.
    * Are you linking to a static library? Or a header-only library?
        * No problem! The static library will be included in the dynamic library as part of the linking stage, and will operate (correctly) as if it’s the only copy of the library (even if other copies of the library exist in other libraries). Once built, it will be as if the static library never existed, and your code simply provided all of that functionality (note that the static library’s symbols will generally NOT be exported by your dynamic library). However, it will cause your library to be bigger (because it includes a full copy of the library you linked to).
* Are you building a static library?
    * Are you linking to a dynamic library?
        * Problem! Static libraries cannot record what they link to, so your library will simply have undefined symbols. Your clients/users will need to explicitly link against that same dynamic library themselves, in order to resolve the symbols.
    * Are you linking to a static library?
        * Problem! Static libraries are really just a collection of object files, with an index (the index is what differentiates static libraries from just an archive of object files). You can, if you want to, unpack the library you’re linking to and repack all of those objects into your library alongside your own object files. But that’s almost always a bad idea: you run the risk of creating situations where there are multiply defined symbols (e.g. if someone else does the same thing with their static library, and you need to link both your library and theirs into an executable) or worse, situations where global variables cannot be reliably initialized/destructed or even used. As strange as it may seem, most likely the “right” thing to do is to treat the static library like a dynamic library: require that your clients/users explicitly link against that library, instead of linking against it yourself.

Building with CMake

How does this interact with PUBLIC and PRIVATE dependencies in CMake?

First, keep in mind that PUBLIC and PRIVATE only affect the target (i.e.the abstract concept of your library, within the confines of CMake), they do *not* affect the library file that you generate.

PUBLIC dependencies are dependencies that you expect everyone who links against your library will also have to link against. CMake has muddied the waters about what “link against” means (and in general this is a very convenient muddying), but for now I am referring to the compiler step of linking. PRIVATE dependencies are (you guessed it) dependencies that you do not expect everyone who links against your library will also have to link against.

Let’s be clear, the library generated by this CMake statement:

add_library(foo foo.cc)
target_link_libraries(foo PUBLIC bar)

will be identical to the library generated by this CMake statement:

add_library(foo foo.cc)
target_link_libraries(foo PRIVATE bar)

The difference is in what happens when you do this:

add_program(baz baz.cc)
target_link_libraries(baz PUBLIC foo)

Another CMake feature you should be aware of is a feature known as IMPORTED targets. These targets tend to have names like Foo::Foo or Foo::bar (instead of simply foo - this isn’t mandatory, but it’s the common style). What’s important about this feature is that these targets have metadata associated with them (“properties” in CMake terms) that affect targets that link against them, and they’re commonly used to refer to external libraries (i.e. from other packages). For instance, imported targets typically know where their associated headers are, and linking against an imported target will add the associated directory in your include search path.

Let’s assume that when you link against external packages, you always use IMPORTED targets.

* When should you PUBLIC-ly link to an external package?
    * If you’re installing header files that include header files from that package. Why? In order for your customers to compile cleanly with your package’s headers, they need to know where all the headers you include are as well. This will have the side-effect that the external package will also be explicitly linked against by your customers, but this is _usually_ harmless. If it becomes a problem, there are ways around it.
* When should you PRIVATE-ly link to an external package?
    * As often as possible - in general, it’s a good idea to avoid external dependencies in your public header files, if you can. This makes compiling faster, and gives you the flexibility to change dependencies at some point without affecting your API.
* When should you link both PUBLIC-ly and PRIVATE-ly to the same external package?
    * Never. There might be cases where it’s helpful to to publicly link against one target from an external package and privately link to a different target from that same external package, but this is an unusual situation.

Imagine you’re compiling the program baz, which depends on libfoo. Libfoo depends on libbar.

You’d like to think that if libfoo depends on libbar privately, then libbar will have no effect on how baz is compiled, but in certain circumstances it does! When libfoo is compiled as a dynamic library, then yes, libbar will have no effect on how baz is compiled. However, when libfoo is compiled as a static library, linking against libbar is perilous (as described in the first section of this document). CMake tries to help by adding all private dependencies to the INTERFACE_LINK_LIBRARIES property of the foo target - which means anyone using CMake to link against the foo target will also link against libbar.

This helpfulness can have unexpected consequences. This is clearer if we use the package-style naming convention. Let’s say that the Foo package builds libfoo and the Bar package builds libbar. They publish (respectively) CMake targets named Foo::Foo and Bar::Bar.

If libfoo is compiled dynamically, the Foo::Foo target published by the package will have an INTERFACE_LINK_LIBRARIES property equal to either -lfoo or the full path to libfoo.so. However, if libfoo is compiled statically, the Foo::Foo target will have an INTERFACE_LINK_LIBRARIES property that includes Bar::Bar as well. Remember that Bar::Bar, as an IMPORTED target, is not defined unless and until you’ve executed the find_package(Bar) command in CMake. Thus, for baz to link against libfoo, the baz package must have run find_package(Bar) first - if you don’t, CMake will complain that Bar::Bar is unknown. This is obviously a challenge, because we would like for baz to be ignorant of libfoo’s dependencies (i.e. libfoo should be able to update its dependencies without needing to patch baz’s build scripts).

The Good

The Modern CMake method of addressing this problem is via the scripts that are involved in the find_package process (preferably, the installed ones, i.e. using the CONFIG method). In this way, the Foo package can publish a short CMake script that will be run by all of its consumers, so Foo can specify that find_package(Bar REQUIRED) must be run before using libfoo.

The Bad

One way to do this is to avoid using IMPORTED targets when linking libfoo. In other words, if you do this in Foo’s CMakeLists.txt file:

find_package(Bar REQUIRED)
add_library(Foo foo.cc)
target_link_library(Foo PRIVATE ${Bar_LIB})

In this case, the INTERFACE_LINK_LIBRARIES will include the absolute path to the libbar library. The benefit of this is that baz doesn’t need to discover the libbar library (via find_package(Bar)). The downside is that libbar cannot be moved between compiling libfoo and compiling baz - in other words, it’s quite fragile.

The Ugly

The least pleasant way to do this is to give up on transitive dependencies altogether, and simply insist that all consumers of the Foo package be aware of all dependencies of the Foo package. Any change to Foo’s dependencies must then result in changes to every consumer of the Foo package... and every consumer of those packages, and every consumer of those packages, and so on.
